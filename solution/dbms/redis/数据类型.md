#数据类型
##SDS[source][2]
大多数情况下Redis使用(SDS)simple dynamic string 作为字符串标示
> + 常数复杂度取字符长度 O(n) -> O(1)
> + 杜绝缓冲区溢出 
    未给字符串分配足够的内存
> + 修改字符串长度需要重新分配内存
>> 1.append可能会导致缓冲区溢出
>> 2.trim可能会导致内存泄漏
>> 3.内存分配是系统调用 ,空间预分配+ 惰性空间释放
> + 二进制安全
> + 兼容部分原生字符串函数
###使用场景
* key|| value
* AOF Buffer
##链表[source][3]
```c
typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
```
> 双端 node节点同时拥有prev 和 next两个指针
> 使用list结构带有 长度，头尾，信息
> 通过指针类型表现为多态 
###使用场景
* 链表
* 发布订阅pubsub
* 慢查询 slow query
* 监视器 monitor
##字典[source][4]
```c
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;

typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```
符号表(symbol table)关联数组(associaive array),映射(map)
> 每个字典带有两个两个hash表,渐进式rehash使用
>> 通过设置rehash index
> 使用MurmurHash
> 被分配到同一个索引的多个键会形成一个单向链表，采用头插法

###使用场景
* hash
* 数据库 database
##跳跃链表[source][5]
```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```
>层高在1…32之间的随机数
>多个节点可包含相同的分值，每个节点的对必须是唯一的
>按照分值大>小排序，当分值相同按照对象大小排序
###为什么使用skiplist 而不是avltree
- 并发访问下更友好,tree可能需要进行rebalance
- 通常以ZRANGE或ZREVRANGE操作的目标
- 更容易实现
###使用场景
* 有序集合底层实现之一 zset
##整数集合[source][6]
>底层实现为数组，数组以有序，无重复方式保存集合元素，会根据新增元素类型改变数组类型
>为整数集合操作操作带来了灵活定，尽可能节省内存
###使用场景
* 整数集合 set encoding intset
##压缩列表[source][7]?
>为节省内存的数据结构
>可包含多个节点，每个节点保存一个字节数组或整数
>新增/删除节点可能引发连锁更新操作
###使用场景
* list 
* hash
#数据对象
RedisObject[git][1]
- string 
>encoding : OBJ_ENCODING_RAW,OBJ_ENCODING_EMBSTR,OBJ_ENCODING_INT
>>jmalloc分配内存为了容纳embstr,会分配32bytes embstr容量 44
- list
>encoding :~~OBJ_ENCODING_LINKEDLIST~~( No longer used: old list encoding) ,OBJ_ENCODING_ZIPLIST,OBJ_ENCODING_QUICKLIST(linked list of ziplists)
- set
>encoding OBJ_ENCODING_INTSET,OBJ_ENCODING_HT
- zset
>encoding OBJ_ENCODING_ZIPLIST,OBJ_ENCODING_SKIPLIST,
- hash
>encoding OBJ_ENCODING_ZIPLIST,OBJ_ENCODING_HT
- module
- stream
>encoding OBJ_ENCODING_STREAM(radix tree of listpacks)

*object encoding*
```c
typedef struct redisObject {
    unsigned type:4; //4bits
    unsigned encoding:4; //4bits
    unsigned lru:LRU_BITS; //24bit 
                            /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount; //4bytes
    void *ptr; //8bytes
} robj;
```
- refcount 引用回收
>reference count 内存回收机制
>*object refcount*
- 对象共享 
> OBJ_SHARED_INTEGERS 0^9999
- 对象空转时常
>*object idletime*
##
- bit -> String -> row
- hyperloglog - > string -> row
- geohash -> zset -> ziplist(?)

   

[1]: https://github.com/antirez/redis/blob/unstable/src/server.h#L450
[2]: https://github.com/antirez/redis/blob/unstable/src/sds.h
[3]: https://github.com/antirez/redis/blob/unstable/src/adlist.h
[4]: https://github.com/antirez/redis/blob/unstable/src/dict.h
[5]: https://github.com/antirez/redis/blob/unstable/src/server.h#L892
[6]: https://github.com/antirez/redis/blob/unstable/src/intset.h
[7]: https://github.com/antirez/redis/blob/unstable/src/ziplist.h