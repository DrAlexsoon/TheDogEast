#分布式锁满足的条件
##存储空间
    锁是一个抽象的概念，锁的实现，需要依存于一个可以存储锁的空间。在多线程中是内存，在多进程中是内存或者磁盘。更重要的是，这个空间是可以被访问到的。多线程中，不同的线程都可以访问到堆中的成员变量；在多进程中，不同的进程可以访问到共享内存中的数据或者存储在磁盘中的文件。但是在分布式环境中，不同的主机很难访问对方的内存或磁盘。这就需要一个都能访问到的外部空间来作为存储空间。
    最普遍的外部存储空间就是数据库了，事实上也确实有基于数据库做分布式锁（行锁、version乐观锁），如quartz集群架构中就有所使用。除此以外，还有各式缓存如Redis、Tair、Memcached、Mongodb，当然还有专门的分布式协调服务Zookeeper，甚至是另一台主机。只要可以存储数据、锁在其中可以被多主机访问到，那就可以作为分布式锁的存储空间。
##唯一标识
    不同的共享资源，必然需要用不同的锁进行保护，因此相应的锁必须有唯一的标识。
    在多线程环境中，锁可以是一个对象，那么对这个对象的引用便是这个唯一标识。
    多进程环境中，信号量在共享内存中也是由引用来作为唯一的标识。但是如果不在内存中，失去了对锁的引用，如何唯一标识它呢？上文提到的有名信号量，便是用硬盘中的文件名作为唯一标识。
    在分布式环境中，只要给这个锁设定一个名称，并且保证这个名称是全局唯一的，那么就可以作为唯一标识。
##至少两种状态
    为了给临界区加锁和解锁，需要存储两种不同的状态。
    ReentrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；
    信号量大于0表示可以进入临界区，小于等于0则表示需要被阻塞。因此只要在分布式环境中，锁的状态有两种或以上：如有锁、没锁；存在、不存在等等，均可以实现
#需要解决的问题
##锁状态判断的原子性
    从读取锁的状态，到判断该状态是否为被锁，需要经历两步操作。
##锁状态无法清除
    我们需要在持有锁的主机宕机或者网络断开的时候，及时的释放掉这把锁
##无法保证释放的是自己上锁的那把锁
    分布式系统下
##可重入
##惊群效应（Herd Effect）
##公平锁和非公平锁
##阻塞和旋转
    阻塞锁会有上下文切换，如果并发量比较高且临界区的操作耗时比较短，那么造成的性能开销就比较大了。
    但是如果临界区操作耗时比较长，一直保持自旋，也会对CPU造成更大的负荷。