#实现原理
    顺序节点+临时节点
- lock
> - 1.create()创建的临时顺序节点。
> - 2.getChildren方法来获取所有已经创建的子节点。
> - 3.若当前线程创建的临时顺序节点为最小节点，则表示当前线程加锁成功;若不是最小节点，则当前线程创建的节点监听比它小的最大节点,阻塞等待被监听节点的删除通知
- unlocks
    删除自己的节点 
#开源实现[menagerie][1]
##可重入
>利用ThreadLocal存储进入的次数，每次加锁次数加1，每次解锁次数减1。如果判断出是当前线程持有锁，就不用走获取锁的流程
##获取锁
>循环判断前序节点是否存在，如果存在则监视该节点并且返回获取失败。如果前序节点不存在，则再判断更前一个节点。如果判断出自己是第一个节点，则返回获取成功。
##公平锁
> - 如果获取尝试锁失败，则进入等待且放弃localLock，等待前序节点唤醒。
> - localLock是一个本地的公平锁，使得condition可以公平的进行唤醒，配合循环判断前序节点，实现了一个公平锁。

#Apache Curator[link][2]


#缺点
- 通过心跳保活机制解决死锁会造成锁的不安全性?

[1]: https://github.com/sfines/menagerie
[2]: http://curator.apache.org/