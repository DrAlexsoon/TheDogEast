#Replication
目的:
- 数据物理上更接近用户(减少延迟)
- 即使数据部分出现故障，也能继续工作(可用性)
- 可以接受更多请求(提高吞吐量)
#单主制复制
##同步异步
同步将所有的从库是不切实际的。使其中部分库保持同步被称为半同步(smi-sync )[7] kafka ISR
通常情况下异步复制不能保持 **持久性**
主从切换:
- 异步复制，导致数据没有了持久性保证
- 脑裂
- 主库超时时间的设置，太长导致恢复时间加长，太短频繁切换，恶化网络
##复制日志的实现
- 基于语句的复制 **任何调用非确定函数会产生不同的值**now()
- WAL(wirte ahead log) 1.日志结构存储引擎日志主要是存储位置 2.对于覆写磁盘的B树，会通过redolog来保持数据的AD 会使日志和存储引擎耦合
- 逻辑日志复制(基于行) mysql Binlog

#多主复制
单个数据中心很少有意义，好处很少超过复杂度，不同数据中心冲突解决
- 多个数据中心，多数数据库支持多主配置
- 需要离线操作的客户端CouchDB
- 协同编辑
##同步异步冲突检测
- 避免冲突[34] 确保特定用户请求始终路由到同一数据中心
- 收敛至一致的状态 
    - 给每个写入设置一个唯一ID，挑选最高ID写入的为准，LWW(LAST WEITE WIN)
    - 为每个副本分配一个唯一ID，ID更高的具有优先写入权
    - 已某种方式合并这些值,git中的冲突

##多主复制拓扑
环形拓扑，星形拓扑 ，all-to-all拓扑
环形和星形:有一个节点发生故障会中断其他节点间的复制,通常需要人工干预
全能拓扑: 因果关系问题，版本向量

#无主复制
Dynamo[37] Riak,Cassandra,Voldmort
##一致性保证
 - 度修复:客户端读取发现有旧版本数据并写回,适合读频繁的系统
 - 反熵:后台进程检查版本之间的差异
 
 ##WNR
 W+R > N
 1.W<R 可以处理写入
 2.R<W 可以处理读取
 3.R = W 可以容忍 N-W 个节点不可用
  - W个写入和R个读取落在完全不同节点 
  - 并发写入 冲突检测/冲突避免
  - 读写并发，不确定返回新值还是旧值
  - 节点写入失败，部分节点上的数据不会回滚
###松散的法定人数|带提示的接力

#延迟导致的一致性模型
- 读之已经写: 从库未读取到已提交的数据。 1.都从主库读 2.记录上次更新时间
- 单调读: 不同副本之前的数据不同步。这种保证是比强一致性弱，但是比最终一致性强的保证。1.通过用户唯一标示，使用户始终从同一个库读取
- 一直前缀: 数据顺序不一致(对话顺序) 1.确保有因果关系都写入到相同的分区

#检测并发写入
 - LWW
 - 捕获 Happen before 
    - 服务器为每个Key保留一个版本号，每次写入增加版本号
    - 读取时返回所有未覆盖的值及版本号，客户端写入前必须读取
    - 客户端写入时，必须将之前读取的所有值合并到一起
    - 服务器接收特定版本号写入，可以覆盖该版本号/更低
 - 合并同时写入的值 数据结构设计出来执行这种合并 CRDT
 - 版本向量