#PUB/SUB
redis将所有的发布订阅关系保存在[source][1]
```c
 /* Pubsub */
    dict *pubsub_channels;  /* Map channels to list of subscribed clients */
    list *pubsub_patterns;  /* A list of pubsub_patterns */
    dict *pubsub_patterns_dict;  /* A dict of pubsub_patterns */
```
##SUBSCRIBE
    负责将客户端和被订阅频道关联到字典
##UNSUBSCRIBE
    解除channel和client的关联
    所有patterns的订阅关系保存在pubsub_patterns
##PUBLISH
    message发送给所有channel，根据pattern match 将消息发送给订阅者
#缺点
1.消息不会持久化
2.没有消费者直接丢弃
3.
#STREAM[source][2]
1.每个消息都有一个唯一的ID和对应的内容。消息是持久化的.
2.stream可以有多个consumerGroup 通过游标last_delivered_id 来确定
3.Consumer/pending_ids 这个 pending_ids 变量在Redis官方被称之为PEL，也就是 Pending Entries List
##高可用
- 依赖于sentinel和cluster
- 不支持原生的partition ，依靠增加stream
##functions
- xadd 追加消息
- xdel 删除消息，这里的删除仅仅是设置了标志位，不影响消息总长度
- xrange 获取消息列表，会自动过滤已经删除的消息
- xlen 消息长度
- del 删除 Stream
#事务
- 将多个命令进行打包，一次性有序的执行，多个命令组成FIFO队列
- 事务在执行过程中不会被中断
- [乐观锁]**WATCH**命令会将[watch_keys][4]相关联,当有key被修改时[CLIENT_DIRTY_CAS][3] 服务器会拒绝事务
##pipeline
事务通常会联合pipeline使用，提升原因在于write写入的sendBuffer(在缓冲区满的时候发生BLOCK),kernel异步发送，read从recvBuffer读取(本地缓冲区为空BLOCK)
##ACID
 - A: 事务原子执行 ,redis不支持 rollback 
 - C: 事务执行前后数据一致 ,通过RDB/AOF可以进行恢复
 - I: 单线程执行
 - D: 通过sync参数可以做到持久性
#本地缓存(6.0)
- 1.default mode 
>>server记录了client访问了哪些key，并在发生变更发送invalidation message,将额外消耗服务器内存
>> - 1.通过**Invalidation Table**通过上线控制,迫使被驱逐的key从客户端失效
>> - 2.不记录client指针，通过clientId,当client失联后无效对应的slot
>> - 3 .不记录database.只通过key
- 2.broadcasting mode 通过pub/sub来
>> - 1.通过**Prefixes Table** 与客户端列表相连
- 对比
>> 1.广播模式下，key存在数据不一致
>> 2.默认模式下服务器会消耗而外内存，广播模式下消耗额外的cpu

[1]: https://github.com/antirez/redis/blob/unstable/src/server.h#L1363
[2]: https://github.com/antirez/redis/blob/unstable/src/stream.h
[3]: https://github.com/antirez/redis/blob/unstable/src/server.h#L213
[4]: https://github.com/antirez/redis/blob/unstable/src/server.h#L648