1.解析字符串写入栈 
- 如果是数字串找到最大字符串
- 如果是\[ |字符 入栈
- 如果是\] 开始出栈 遇到\[截止,通过前面的数字重复若干次
依次遍历
返回字符串list 拼接输出
```java
class Solution {
    public String decodeString(String s) {
        //1.解析数字入栈 2.左进栈数字进栈 3.右括号出栈
        LinkedList<String> stack = new LinkedList<>();

        int i = 0;
        while (i < s.length()) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                StringBuilder stringBuilder = new StringBuilder();
                while (Character.isDigit(s.charAt(i))) {
                    stringBuilder.append(s.charAt(i++));
                }
                stack.push(stringBuilder.toString());
            } else if (Character.isLetter(c) || c == '[') {
                i++;
                stack.push(String.valueOf(c));
            } else {
                i++;
                LinkedList<String> list = new LinkedList<>();
                while (!"[".equals(stack.peek())) {
                    list.add(stack.pop());
                }
                Collections.reverse(list);
                stack.pop();
                Integer times = Integer.valueOf(stack.pop());
                String tmp = buildString(list);
                StringBuilder sb = new StringBuilder();
                while (times > 0) {
                    sb.append(tmp);
                    times--;
                }
                stack.push(sb.toString());
            }
        }
        return getString(stack);
    }

    String getString(LinkedList<String> list) {
        StringBuilder stringBuilder = new StringBuilder();
        while (!list.isEmpty()) {
            stringBuilder.append(list.pollLast());
        }
        return stringBuilder.toString();
    }

    String buildString(LinkedList<String> list) {
        StringBuilder stringBuilder = new StringBuilder();
        while (!list.isEmpty()) {
            stringBuilder.append(list.pollFirst());
        }
        return stringBuilder.toString();
    }
}
```